<!DOCTYPE html>
<html>
    <head>
        <title>VRChoir</title>
        <meta charset="UTF-8" />
    		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    		<link type="text/css" rel="stylesheet" href="main.css">

        <script src="js/three.js"></script>
        <script src="js/GLTFLoader.js"></script>
        <script src="js/VRButton.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/head-socket.js"></script>
        <script src="components/objects/Aaron.js"></script>

    </head>

    <body>
      <div id="overlay">
		<button id="startButton">Play</button>
	</div>
        <script>

            let controls, group;

            let container;
            let camera, scene, renderer, clock, listener;
            let rons;
            let controller1, controller2;
            let controllerGrip1, controllerGrip2;

            let raycaster;


            const startButton = document.getElementById( 'startButton' );
            startButton.addEventListener( 'click', init );


            function init() {

        			const overlay = document.getElementById( 'overlay' );
        			overlay.remove();

              clock = new THREE.Clock();

            	container = document.createElement( 'div' );
            	document.body.appendChild( container );

            	scene = new THREE.Scene();
            	scene.background = new THREE.Color( 0x0f0f0f );
              scene.fog = new THREE.Fog( 0x0f0f0f, 0, 40 );
              rons = new THREE.Group();
              scene.add(rons)

            	camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 0.1, 100 );
            	camera.position.set( 0, 0, 1);

            	controls = new THREE.OrbitControls( camera, container );
            	controls.target.set( 0, 0, 0 );
              controls.autoRotate = true;
              controls.autoRotateSpeed = 5;
            	controls.update();

            	// Configure lights
            	const light1 = new THREE.DirectionalLight( 0x7268B0 );
            	light1.position.set( 3, -1, 3 );
            	light1.castShadow = true;
            	scene.add( light1 );
              const light2 = new THREE.DirectionalLight( 0xDC8CB0 );
            	light2.position.set( 3, -1, -3 );
            	light2.castShadow = true;
            	scene.add( light2 );
              const light3 = new THREE.DirectionalLight( 0x2DD220 );
            	light3.position.set( -3, -1, -3 );
            	light3.castShadow = true;
            	scene.add( light3 );
              const light4 = new THREE.DirectionalLight( 0xE721A0 );
            	light4.position.set( -3, -1, 3 );
            	light4.castShadow = true;
            	scene.add( light4);

            	const geometries = [
            		new THREE.BoxGeometry( 0.2, 0.2, 0.2 ),
            		new THREE.ConeGeometry( 0.2, 0.2, 64 ),
            		new THREE.CylinderGeometry( 0.2, 0.2, 0.2, 64 ),
            		new THREE.IcosahedronGeometry( 0.2, 8 ),
            		new THREE.TorusGeometry( 0.2, 0.04, 64, 32 )
            	];

            	renderer = new THREE.WebGLRenderer( { antialias: true } );
            	renderer.setPixelRatio( window.devicePixelRatio );
            	renderer.setSize( window.innerWidth, window.innerHeight );
            	renderer.outputEncoding = THREE.sRGBEncoding;
            	renderer.shadowMap.enabled = true;
            	renderer.xr.enabled = true;
            	container.appendChild( renderer.domElement );

            	document.body.appendChild( VRButton.createButton( renderer ) );

            	raycaster = new THREE.Raycaster();

            	window.addEventListener( 'resize', onWindowResize );

              listener = new THREE.AudioListener()
              camera.add( listener )

              animate();
            }

            function onWindowResize() {

            	camera.aspect = window.innerWidth / window.innerHeight;
            	camera.updateProjectionMatrix();

            	renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {
            	renderer.setAnimationLoop( render );
            }

            var prevY = 0
            var head_y = -2
            var head_xy = 0
            var head_counter = 0
            function update() {
              controls.update()
              let timeStamp = clock.getElapsedTime();
              // add floating
              // for (let i = 0; i < rons.children.length; i++){
              //   var newY = 0.02 * Math.sin(timeStamp * 4 + (i * 100));
              //   var deltaY = newY - prevY;
              //   rons.children[i].position.y += deltaY;
              //   prevY = newY;
              //   // rons.children[i].rotation.y += 0.007;
              // }
              if (((parseInt(timeStamp)/head_counter) == 1 || head_counter == 0) && head_y < 2) {
                if (head_counter % 2 == 0) {
                  addHead(head_y, head_xy, "swan", 0)
                }
                else {
                  addHead(head_y, head_xy, "lee", Math.PI)
                  head_xy += Math.PI/3
                }
                head_counter += 1
                if (head_counter % 6 == 0) {
                  head_y += 0.5
                }
              }
            }

            function render() {
              update()
            	renderer.render( scene, camera );
            }

            function addHead(y, xz, voice, offset) {
              let radius = 1
              let size = 3

              if ((y * 2) % 2 == 0){
                radius = 2
              } else {
                radius = 1
              }
              const ron = new Aaron(group);

              if ((y * 2 % 2) == 0) {
                ron.position.x = Math.cos(xz + offset)* radius
            		ron.position.y = y
            		ron.position.z = Math.sin(xz + offset)* radius
              } else {
                ron.position.x = Math.cos(xz + offset + Math.PI / 6)* radius
            		ron.position.y = y
            		ron.position.z = Math.sin(xz + offset +  Math.PI / 6)* radius
              }

          		ron.scale.setScalar( size);
              ron.lookAt(0, ron.position.y, 0);

          		ron.castShadow = true;
          		ron.receiveShadow = true;

              // if ((y * 2 % 2) == 0) {
              //   ron.rotdir = true
              // } else {
              //   ron.rotdir = false
              // }
              let level = (y + 2)* 2
              let audio_file = 'sounds/' + voice + level + '.mp3'
              const sound = new THREE.PositionalAudio( listener );

              // load a sound and set it as the PositionalAudio object's buffer
              const audioLoader = new THREE.AudioLoader();
              audioLoader.load( audio_file, function( buffer ) {
              	sound.setBuffer( buffer );
              	sound.setRefDistance( 0.1 );
                sound.setDirectionalCone( 180, 230, 0.1 );
              	sound.play();
              });
              // finally add the sound to the mesh
              ron.add( sound );
          		rons.add( ron );
              console.log(audio_file);
              // create the PositionalAudio object (passing in the listener)

          	}

        </script>
    </body>
</html>
